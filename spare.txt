// "kinCorrections": {
    //     "p_delta_p_FD": {
    //         "form": "[0] + [1]/p + [2]/p^2",
    //         "coeffs": {
    //             "0": [-0.008805111502654742, 0.0004978760384687152],
    //             "1": [0.01983358224028466, -0.0007917574729338918],
    //             "2": [-0.016389187677611543, 0.0008558870251674676]
    //         }
    //     },
    //     "p_delta_p_CD" : {
    //         "form": "[0] + [1]*p + [2]*p^2",
    //         "coeffs": {
    //             "0": [-0.020253177247514884, 0.0005728847468402564, -4.249900472884533e-06],
    //             "1": [-0.025541168462974252, 0.0018651926553191701, -1.8328619167119578e-05],
    //             "2": [0.03565243616031444, -0.0018632877820618293, 1.6120569653443098e-05]
    //         }
    //     },
    //     "p_delta_theta_FD": {
    //         "form":"[0] + [1]/p",
    //         "coeffs": {
    //             "0": [-0.6600564020616334, 0.07251620425419004, -0.002634727394660484, 3.1659541829217516e-05],
    //             "1": [1.9088118497441375, -0.2152693346102051, 0.007989446635956406, -9.786632435544166e-05]
    //         }
    //     },
    //     "p_delta_theta_CD": {
    //         "form":"[0] + [1]*p",
    //         "coeffs": {
    //             "0": [-0.09164758170608486, 0.004096566738065135, -4.3408337653072516e-05],
    //             "1": [0.13352565904056415, -0.005655088857163317, 5.730614876230532e-05]
    //         }
    //     },
    //     "p_delta_phi_FD": {
    //         "form": "[0] + [1]/p",
    //         "coeffs": {
    //             "0": [-1.644154767540893, 0.19351949721638026, -0.007299362995406794, 8.859632573675951e-05],
    //             "1": [3.7467848308850886, -0.4339416044141568, 0.016233585945593265, -0.00019279526620589912]
    //         }
    //     },
    //     "p_delta_phi_CD": {
    //         "form": "[0] + [1]*p + [2]*p^2",
    //         "coeffs": {
    //             "0": [-0.024087519132615677, 0.001096997051079076, -1.1698250343428828e-05],
    //             "1": [0.019170042504978436, -0.0010928104454744393, 2.0558323822827794e-05],
    //             "2": [-0.003440000334921699, 0.00036400710786097396, -1.3803541802484884e-05]
    //         }
    //     }
    // }



    def show_by_sector(particle, df, layer_name, y_branch, x_branch, sector_branch, x_range=None, y_range=None, x_bins=100, y_bins=100, log_scale=False):
    fig, axes = plt.subplots(2, 3, figsize=(18, 9), constrained_layout=True)
    
     # Default bin ranges based on variable if not supplied
    if x_range is None:
        x_vals = df.AsNumpy([x_branch])[x_branch]
        x_range = (np.min(x_vals), np.max(x_vals))
    if y_range is None:
        y_vals = df.AsNumpy([y_branch])[y_branch]
        y_range = (np.min(y_vals), np.max(y_vals))

    bins_x = np.linspace(x_range[0], x_range[1], x_bins+1)
    bins_y = np.linspace(y_range[0], y_range[1], y_bins+1)

    for sec in range(1, 7):
        ax = axes[(sec - 1) // 3, (sec - 1) % 3]

        # Filter for this sector
        df_sec = df.Filter(f"{sector_branch} == {sec}")

        # Directly get NumPy arrays from RDataFrame
        arrays = df_sec.AsNumpy([x_branch, y_branch])
        x_vals = arrays[x_branch]
        y_vals = arrays[y_branch]

        # Build 2D histogram
        H, xedges, yedges = np.histogram2d(x_vals, y_vals, bins=[bins_x, bins_y])

        if log_scale:
            norm = LogNorm(vmin=1, vmax=H.max() if H.max() > 0 else 1)
        else:
            # Avoid zero washing out: scale from min positive to max
            H_nonzero = H[H > 0]
            if H_nonzero.size > 0:
                vmin = H_nonzero.min()
            else:
                vmin = 0
            norm = Normalize(vmin=vmin, vmax=H.max())

        # Plot
        im = ax.imshow(
            H.T, origin='lower',
            extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]],
            aspect='auto', interpolation='nearest', cmap='cividis',
            norm=norm)
        

        ax.set_title(f"{layer_name} - Sector {sec}")
        ax.set_xlabel(f"{x_branch}")
        ax.set_ylabel(f"{y_branch}")
        fig.colorbar(im, ax=ax, orientation='vertical', label='Counts')

    plt.suptitle(f"2D Histograms of {layer_name}: {y_branch} vs {x_branch} by Sector")
    plt.savefig(f"{particle}_{layer_name}_bySector.png")
    plt.close(fig)
